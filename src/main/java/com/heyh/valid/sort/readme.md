## 快速排序

[快速排序（java实现）](https://blog.csdn.net/shujuelin/article/details/82423852)

快速排序的核心是“分治”，即将数组分为有序的 k 个小数组（这一时刻小数组内元素不要求有序，但 k 个小数组应该是有序的），再然后保证每个小数组内元素有序，这样一来整个数组就有序了。

**思路**：
1. 每次遍历数组都找出一个“基准”，基准左侧的都比基准小，右侧的都比基准大，所以首先需要考虑实现的就是找出一个“基准数”然后将它放到它应该出现的位置上 --- **快排的核心就是找基准放对位置**。
2. 第一次遍历数组会找出一个基准，数组会被分为左右两个半区，然后通过递归方式我们分别对两个半区再执行一次找基准，通过不停的找基准，实现数组排序。

**实现**：将数组第一个元素设为基准数，定义左右两个指针分别移动。右指针找小于基准数的元素，找到满足条件的元素或与左指针相遇就停止移动；左指针找大于等于基准数的元素，找到满足条件的元素或与右指针相遇就停止移动。左右指针都停下后，互换二者位置上的元素，然后指针继续移动。

当左右指针都停止移动后，说明二者在某一位置上相遇了，将基准数与左右指针相遇位置元素互换，此时基准数元素全都小于基准数，基准数右侧元素均大于基准数，一次 **找基准** 结束。

数组被基准数一分为二，通过递归的办法，分别对左右两部分数组进行“找基准”，这就是**递归找基准**，退出递归的条件为左右指针相同，即所有被基准数分隔而成的小数组都排序完毕。

##### # 细节1
将数组第一个元素设为基准数后，左右两指针每次必须是右侧指针先动，左侧指针后动。
> **因为**，若先动左指针，找到一个比基准数大的元素 a1 后停下，再移动右指针，若移动过程中没有比基准数小的元素，此时右指针会在 a1 位置与左指针相遇，按照算法，a1 会同基准数交换位置，这样一来，基准数左侧会出现大于基准数的元素，因为 a1 大于基准数。
> **所以**，左右指针每次移动必须先动右指针。
> 
> **结论**：之所以要求先动右指针是因为我们排序数组是从左往右 从小到大的原则排序，初始基准数又是数组首位，所以我们必须先找小于基准数的元素，这样才能确保左侧元素全部小于基准数。

##### # 细节2
在左右指针移动过程中，分别找的是大于基准数和小于基准数的元素，这里并没有对等于基准数的元素做特殊处理，为什么？
> 当目标数组按基准数一分为二之后，若左侧有等于基准数的元素，那么在若干次 “找基准” 过后，必定会出现在最靠近基准数的位置上，因为它是左侧元素的最大值。同理，右侧存在的等于基准数的元素会是右侧所有元素的最小值，会在基准数位置之后一位紧挨着，不影响这部分目标数组重新 “找基准”。
> 
> **结论**：对于等于基准数的元素，无需特殊处理，并不影响每次 “找基准”。

##### # 细节3
“找基准”这个操作是递归进行的，既是递归那么就必须有退出递归的条件，否则就是死循环。
> 这里给 “找基准” 设置的条件是判断数组开始位置是否大于结束位置，而非大于等于。一次“找基准”执行完毕左右指针会指向同一位置，这时会根据左右不同进行递归操作，左侧递归传入的结束位置参数为 基准索引 -1，右侧递归传入的开始位置为 基准数索引 +1，递归参数 start 不可能会等于 end，所以 >= 和 > 没区别。